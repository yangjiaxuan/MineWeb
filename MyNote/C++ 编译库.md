## C/C++ 编译静态库 动态库
#### 1、简介
##### <font color='red'>静态链接库(.a)</font>：即在链接阶段，将源文件中用到的库函数与汇编生成的目标文件.o合并生成可执行文件。该可执行文件可能会比较大。这种链接方式的好处是：方便程序移植，因为可执行程序与库函数再无关系，放在如何环境当中都可以执行。缺点是：文件太大，一个全静态方式生成的简单print文件都有857K。而动态链接生成的一样的可执行文件却只要8.４Ｋ。
##### <font color='red'>动态链接库(.so)</font>:在内存中仅有一份代码，在程序运行过程中动态调用库文件，很方便，又不占空间，但是动态链接有一个缺点就是可移植性太差，如果两台电脑运行环境不同，动态库存放的位置不一样，很可能导致程序运行失败。

#### 2、编译
##### 编译过程：`预编译`->`编译`->`汇编`->`链接`
- 预编译: 源文件（.h .cpp）
- 链接 :可执行文件（.a/.lib .so/.dll）

###### 基本操作：
``` 
gcc -c a.c // 生成一个helloWorld.o文件，该文件是将源文件编译成的汇编文件，在链接之前，该文件不是可执行文件。
gcc -o a a.c // 生成的是一个helloWorld的执行文件，格式为ELF（与windows不一样）。该文件为链接后的可执行文件。
```

##### 1) 静态库编译
###### 编译链接静态库
```
库文件：a.h、a.cpp
g++ -c a.cpp //生.o目标文件
ar -crv alib.a a.o // 进一步将.o生成静态库alib.a
```
###### 上面创建的是链接库，所以正在使用的时候，编译使用文件时必须要指定库。假设在test.cpp中使用了 alib.a库。
```
g++ -o test test.cpp ./alib.a // 由于test.cpp依赖于alib.a，所以编译时./alib.a要写在 test.cpp的后面。

./test // 运行编译后的test可执行文件
```


##### 2) 动态库编辑
```
g++ -fPIC -shared -o alib.so a.cpp // 生成一个动态库

使用 alib.so 库
g++ -o test test.cpp ./alib.so

./test  // 运行编译后的test可执行文件

``` 

#### 3） g++ 编译选项
```
-shared ：指定生成动态链接库。
-static ：指定生成静态链接库。
-fPIC   ：表示编译为位置独立的代码，用于编译共享库。目标文件需要创建成位置无关码，念上就是在可执行程序装载它们的时候，它们可以放在可执行程序的内存里的任何地方。
-L.     ：表示要连接的库所在的目录。
-l      ：指定链接时需要的动态库。编译器查找动态连接库时有隐含的命名规则，即在给出的名字前面加上lib，后面加上.a/.so来确定库的名称。
-Wall   ：生成所有警告信息。
-ggdb   ：此选项将尽可能的生成gdb的可以使用的调试信息。
-g      ：编译器在编译的时候产生调试信息。
-c      ：只激活预处理、编译和汇编,也就是把程序做成目标文件(.o文件)。
-Wl,options ：把参数(options)传递给链接器ld。如果options中间有逗号,就将options分成多个选项，然后传递给链接程序。
```

